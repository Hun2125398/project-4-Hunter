In developing the Bag class and its test suite, I worked with AI to refine and extend my Java code. I started with a working implementation of a generic Bag data structure that used an ArrayList internally. With AI assistance, I confirmed that my class correctly implemented the Container interface and followed good Java design practices, such as using generics safely, validating inputs, and documenting complexity. The AI also helped me create a complete JUnit 5 test suite that checked all major behaviors — including empty bags, single and multiple elements, removal logic, and iterator functionality — ensuring full coverage and robust edge-case handling.
Through this process, I learned how to structure tests more methodically, how to use @Nested and @DisplayName annotations for clarity, and how to diagnose IntelliJ build path issues like unmarked test source roots. I also gained a stronger understanding of time complexity, immutability, and best practices in class design.
Although AI greatly accelerated the process by suggesting structure, coverage ideas, and cleaner code organization, I was still essential in shaping the design, verifying logic, and making key decisions about how the Bag class should behave. My role was to provide intent, review AI output, and ensure the final code met both my functional goals and my personal coding style. In short, AI enhanced productivity and learning, but the creativity, understanding, and final decisions remained mine.